# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateEvent {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
}

type AggregateInstrument {
  _avg: InstrumentAvgAggregate
  _count: InstrumentCountAggregate
  _max: InstrumentMaxAggregate
  _min: InstrumentMinAggregate
  _sum: InstrumentSumAggregate
}

type AggregateSession {
  _avg: SessionAvgAggregate
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
  _sum: SessionSumAggregate
}

type AggregateSong {
  _avg: SongAvgAggregate
  _count: SongCountAggregate
  _max: SongMaxAggregate
  _min: SongMinAggregate
  _sum: SongSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumToken_typeFieldUpdateOperationsInput {
  set: Token_type
}

input EnumToken_typeFilter {
  equals: Token_type
  in: [Token_type!]
  not: NestedEnumToken_typeFilter
  notIn: [Token_type!]
}

input EnumUser_roleFieldUpdateOperationsInput {
  set: User_role
}

input EnumUser_roleFilter {
  equals: User_role
  in: [User_role!]
  not: NestedEnumUser_roleFilter
  notIn: [User_role!]
}

input EnumUser_roleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumUser_roleFilter
  _min: NestedEnumUser_roleFilter
  equals: User_role
  in: [User_role!]
  not: NestedEnumUser_roleWithAggregatesFilter
  notIn: [User_role!]
}

type Event {
  _count: EventCount
  active: Int!
  createdAt: DateTime!
  description: String
  id: Int!
  location: String
  name: String!
  notes: String
  songs(cursor: EventSongWhereUniqueInput, distinct: [EventSongScalarFieldEnum!], orderBy: [EventSongOrderByWithRelationInput!], skip: Int, take: Int, where: EventSongWhereInput): [EventSong!]!
  startDateTime: DateTime
  telephone: String
  updatedAt: DateTime!
  venue: String
}

type EventAvgAggregate {
  active: Float
  id: Float
}

input EventAvgOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
}

type EventCount {
  songs: Int!
}

type EventCountAggregate {
  _all: Int!
  active: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  location: Int!
  name: Int!
  notes: Int!
  startDateTime: Int!
  telephone: Int!
  updatedAt: Int!
  venue: Int!
}

input EventCountOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  notes: SortOrder
  startDateTime: SortOrder
  telephone: SortOrder
  updatedAt: SortOrder
  venue: SortOrder
}

input EventCreateInput {
  active: Int!
  createdAt: DateTime
  description: String
  location: String
  name: String!
  notes: String
  songs: EventSongCreateNestedManyWithoutEventInput
  startDateTime: DateTime
  telephone: String
  updatedAt: DateTime
  venue: String
}

input EventCreateManyInput {
  active: Int!
  createdAt: DateTime
  description: String
  id: Int
  location: String
  name: String!
  notes: String
  startDateTime: DateTime
  telephone: String
  updatedAt: DateTime
  venue: String
}

input EventCreateNestedOneWithoutSongsInput {
  connect: EventWhereUniqueInput
  connectOrCreate: EventCreateOrConnectWithoutSongsInput
  create: EventCreateWithoutSongsInput
}

input EventCreateOrConnectWithoutSongsInput {
  create: EventCreateWithoutSongsInput!
  where: EventWhereUniqueInput!
}

input EventCreateWithoutSongsInput {
  active: Int!
  createdAt: DateTime
  description: String
  location: String
  name: String!
  notes: String
  startDateTime: DateTime
  telephone: String
  updatedAt: DateTime
  venue: String
}

type EventGroupBy {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
  active: Int!
  createdAt: DateTime!
  description: String
  id: Int!
  location: String
  name: String!
  notes: String
  startDateTime: DateTime
  telephone: String
  updatedAt: DateTime!
  venue: String
}

type EventMaxAggregate {
  active: Int
  createdAt: DateTime
  description: String
  id: Int
  location: String
  name: String
  notes: String
  startDateTime: DateTime
  telephone: String
  updatedAt: DateTime
  venue: String
}

input EventMaxOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  notes: SortOrder
  startDateTime: SortOrder
  telephone: SortOrder
  updatedAt: SortOrder
  venue: SortOrder
}

type EventMinAggregate {
  active: Int
  createdAt: DateTime
  description: String
  id: Int
  location: String
  name: String
  notes: String
  startDateTime: DateTime
  telephone: String
  updatedAt: DateTime
  venue: String
}

input EventMinOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  notes: SortOrder
  startDateTime: SortOrder
  telephone: SortOrder
  updatedAt: SortOrder
  venue: SortOrder
}

input EventOrderByWithAggregationInput {
  _avg: EventAvgOrderByAggregateInput
  _count: EventCountOrderByAggregateInput
  _max: EventMaxOrderByAggregateInput
  _min: EventMinOrderByAggregateInput
  _sum: EventSumOrderByAggregateInput
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  notes: SortOrder
  startDateTime: SortOrder
  telephone: SortOrder
  updatedAt: SortOrder
  venue: SortOrder
}

input EventOrderByWithRelationInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  notes: SortOrder
  songs: EventSongOrderByRelationAggregateInput
  startDateTime: SortOrder
  telephone: SortOrder
  updatedAt: SortOrder
  venue: SortOrder
}

input EventRelationFilter {
  is: EventWhereInput
  isNot: EventWhereInput
}

enum EventScalarFieldEnum {
  active
  createdAt
  description
  id
  location
  name
  notes
  startDateTime
  telephone
  updatedAt
  venue
}

input EventScalarWhereWithAggregatesInput {
  AND: [EventScalarWhereWithAggregatesInput!]
  NOT: [EventScalarWhereWithAggregatesInput!]
  OR: [EventScalarWhereWithAggregatesInput!]
  active: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  location: StringNullableWithAggregatesFilter
  name: StringWithAggregatesFilter
  notes: StringNullableWithAggregatesFilter
  startDateTime: DateTimeNullableWithAggregatesFilter
  telephone: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  venue: StringNullableWithAggregatesFilter
}

type EventSong {
  createdAt: DateTime!
  eventId: Int
  id: Int!
  songId: Int
}

input EventSongCreateManyEventInput {
  createdAt: DateTime
  id: Int
  songId: Int
}

input EventSongCreateManyEventInputEnvelope {
  data: [EventSongCreateManyEventInput!]!
  skipDuplicates: Boolean
}

input EventSongCreateManySongInput {
  createdAt: DateTime
  eventId: Int
  id: Int
}

input EventSongCreateManySongInputEnvelope {
  data: [EventSongCreateManySongInput!]!
  skipDuplicates: Boolean
}

input EventSongCreateNestedManyWithoutEventInput {
  connect: [EventSongWhereUniqueInput!]
  connectOrCreate: [EventSongCreateOrConnectWithoutEventInput!]
  create: [EventSongCreateWithoutEventInput!]
  createMany: EventSongCreateManyEventInputEnvelope
}

input EventSongCreateNestedManyWithoutSongInput {
  connect: [EventSongWhereUniqueInput!]
  connectOrCreate: [EventSongCreateOrConnectWithoutSongInput!]
  create: [EventSongCreateWithoutSongInput!]
  createMany: EventSongCreateManySongInputEnvelope
}

input EventSongCreateOrConnectWithoutEventInput {
  create: EventSongCreateWithoutEventInput!
  where: EventSongWhereUniqueInput!
}

input EventSongCreateOrConnectWithoutSongInput {
  create: EventSongCreateWithoutSongInput!
  where: EventSongWhereUniqueInput!
}

input EventSongCreateWithoutEventInput {
  createdAt: DateTime
  song: SongCreateNestedOneWithoutEventsInput
}

input EventSongCreateWithoutSongInput {
  createdAt: DateTime
  event: EventCreateNestedOneWithoutSongsInput
}

input EventSongListRelationFilter {
  every: EventSongWhereInput
  none: EventSongWhereInput
  some: EventSongWhereInput
}

input EventSongOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventSongOrderByWithRelationInput {
  createdAt: SortOrder
  event: EventOrderByWithRelationInput
  eventId: SortOrder
  id: SortOrder
  song: SongOrderByWithRelationInput
  songId: SortOrder
}

enum EventSongScalarFieldEnum {
  createdAt
  eventId
  id
  songId
}

input EventSongScalarWhereInput {
  AND: [EventSongScalarWhereInput!]
  NOT: [EventSongScalarWhereInput!]
  OR: [EventSongScalarWhereInput!]
  createdAt: DateTimeFilter
  eventId: IntNullableFilter
  id: IntFilter
  songId: IntNullableFilter
}

input EventSongUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
}

input EventSongUpdateManyWithWhereWithoutEventInput {
  data: EventSongUpdateManyMutationInput!
  where: EventSongScalarWhereInput!
}

input EventSongUpdateManyWithWhereWithoutSongInput {
  data: EventSongUpdateManyMutationInput!
  where: EventSongScalarWhereInput!
}

input EventSongUpdateManyWithoutEventNestedInput {
  connect: [EventSongWhereUniqueInput!]
  connectOrCreate: [EventSongCreateOrConnectWithoutEventInput!]
  create: [EventSongCreateWithoutEventInput!]
  createMany: EventSongCreateManyEventInputEnvelope
  delete: [EventSongWhereUniqueInput!]
  deleteMany: [EventSongScalarWhereInput!]
  disconnect: [EventSongWhereUniqueInput!]
  set: [EventSongWhereUniqueInput!]
  update: [EventSongUpdateWithWhereUniqueWithoutEventInput!]
  updateMany: [EventSongUpdateManyWithWhereWithoutEventInput!]
  upsert: [EventSongUpsertWithWhereUniqueWithoutEventInput!]
}

input EventSongUpdateManyWithoutSongNestedInput {
  connect: [EventSongWhereUniqueInput!]
  connectOrCreate: [EventSongCreateOrConnectWithoutSongInput!]
  create: [EventSongCreateWithoutSongInput!]
  createMany: EventSongCreateManySongInputEnvelope
  delete: [EventSongWhereUniqueInput!]
  deleteMany: [EventSongScalarWhereInput!]
  disconnect: [EventSongWhereUniqueInput!]
  set: [EventSongWhereUniqueInput!]
  update: [EventSongUpdateWithWhereUniqueWithoutSongInput!]
  updateMany: [EventSongUpdateManyWithWhereWithoutSongInput!]
  upsert: [EventSongUpsertWithWhereUniqueWithoutSongInput!]
}

input EventSongUpdateWithWhereUniqueWithoutEventInput {
  data: EventSongUpdateWithoutEventInput!
  where: EventSongWhereUniqueInput!
}

input EventSongUpdateWithWhereUniqueWithoutSongInput {
  data: EventSongUpdateWithoutSongInput!
  where: EventSongWhereUniqueInput!
}

input EventSongUpdateWithoutEventInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  song: SongUpdateOneWithoutEventsNestedInput
}

input EventSongUpdateWithoutSongInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  event: EventUpdateOneWithoutSongsNestedInput
}

input EventSongUpsertWithWhereUniqueWithoutEventInput {
  create: EventSongCreateWithoutEventInput!
  update: EventSongUpdateWithoutEventInput!
  where: EventSongWhereUniqueInput!
}

input EventSongUpsertWithWhereUniqueWithoutSongInput {
  create: EventSongCreateWithoutSongInput!
  update: EventSongUpdateWithoutSongInput!
  where: EventSongWhereUniqueInput!
}

input EventSongWhereInput {
  AND: [EventSongWhereInput!]
  NOT: [EventSongWhereInput!]
  OR: [EventSongWhereInput!]
  createdAt: DateTimeFilter
  event: EventRelationFilter
  eventId: IntNullableFilter
  id: IntFilter
  song: SongRelationFilter
  songId: IntNullableFilter
}

input EventSongWhereUniqueInput {
  id: Int
}

type EventSumAggregate {
  active: Int
  id: Int
}

input EventSumOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
}

input EventUpdateInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  location: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  notes: NullableStringFieldUpdateOperationsInput
  songs: EventSongUpdateManyWithoutEventNestedInput
  startDateTime: NullableDateTimeFieldUpdateOperationsInput
  telephone: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  venue: NullableStringFieldUpdateOperationsInput
}

input EventUpdateManyMutationInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  location: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  notes: NullableStringFieldUpdateOperationsInput
  startDateTime: NullableDateTimeFieldUpdateOperationsInput
  telephone: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  venue: NullableStringFieldUpdateOperationsInput
}

input EventUpdateOneWithoutSongsNestedInput {
  connect: EventWhereUniqueInput
  connectOrCreate: EventCreateOrConnectWithoutSongsInput
  create: EventCreateWithoutSongsInput
  delete: Boolean
  disconnect: Boolean
  update: EventUpdateWithoutSongsInput
  upsert: EventUpsertWithoutSongsInput
}

input EventUpdateWithoutSongsInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  location: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  notes: NullableStringFieldUpdateOperationsInput
  startDateTime: NullableDateTimeFieldUpdateOperationsInput
  telephone: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  venue: NullableStringFieldUpdateOperationsInput
}

input EventUpsertWithoutSongsInput {
  create: EventCreateWithoutSongsInput!
  update: EventUpdateWithoutSongsInput!
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  active: IntFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  location: StringNullableFilter
  name: StringFilter
  notes: StringNullableFilter
  songs: EventSongListRelationFilter
  startDateTime: DateTimeNullableFilter
  telephone: StringNullableFilter
  updatedAt: DateTimeFilter
  venue: StringNullableFilter
}

input EventWhereUniqueInput {
  id: Int
}

type Instrument {
  _count: InstrumentCount
  active: Int!
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  songs(cursor: InstrumentSongWhereUniqueInput, distinct: [InstrumentSongScalarFieldEnum!], orderBy: [InstrumentSongOrderByWithRelationInput!], skip: Int, take: Int, where: InstrumentSongWhereInput): [InstrumentSong!]!
  updatedAt: DateTime!
}

type InstrumentAvgAggregate {
  active: Float
  id: Float
}

input InstrumentAvgOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
}

type InstrumentCount {
  songs: Int!
}

type InstrumentCountAggregate {
  _all: Int!
  active: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input InstrumentCountOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input InstrumentCreateInput {
  active: Int!
  createdAt: DateTime
  description: String
  name: String!
  songs: InstrumentSongCreateNestedManyWithoutInstrumentsInput
  updatedAt: DateTime
}

input InstrumentCreateManyInput {
  active: Int!
  createdAt: DateTime
  description: String
  id: Int
  name: String!
  updatedAt: DateTime
}

input InstrumentCreateNestedOneWithoutSongsInput {
  connect: InstrumentWhereUniqueInput
  connectOrCreate: InstrumentCreateOrConnectWithoutSongsInput
  create: InstrumentCreateWithoutSongsInput
}

input InstrumentCreateOrConnectWithoutSongsInput {
  create: InstrumentCreateWithoutSongsInput!
  where: InstrumentWhereUniqueInput!
}

input InstrumentCreateWithoutSongsInput {
  active: Int!
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
}

type InstrumentGroupBy {
  _avg: InstrumentAvgAggregate
  _count: InstrumentCountAggregate
  _max: InstrumentMaxAggregate
  _min: InstrumentMinAggregate
  _sum: InstrumentSumAggregate
  active: Int!
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  updatedAt: DateTime!
}

type InstrumentMaxAggregate {
  active: Int
  createdAt: DateTime
  description: String
  id: Int
  name: String
  updatedAt: DateTime
}

input InstrumentMaxOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type InstrumentMinAggregate {
  active: Int
  createdAt: DateTime
  description: String
  id: Int
  name: String
  updatedAt: DateTime
}

input InstrumentMinOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input InstrumentOrderByWithAggregationInput {
  _avg: InstrumentAvgOrderByAggregateInput
  _count: InstrumentCountOrderByAggregateInput
  _max: InstrumentMaxOrderByAggregateInput
  _min: InstrumentMinOrderByAggregateInput
  _sum: InstrumentSumOrderByAggregateInput
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input InstrumentOrderByWithRelationInput {
  active: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  songs: InstrumentSongOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input InstrumentRelationFilter {
  is: InstrumentWhereInput
  isNot: InstrumentWhereInput
}

enum InstrumentScalarFieldEnum {
  active
  createdAt
  description
  id
  name
  updatedAt
}

input InstrumentScalarWhereWithAggregatesInput {
  AND: [InstrumentScalarWhereWithAggregatesInput!]
  NOT: [InstrumentScalarWhereWithAggregatesInput!]
  OR: [InstrumentScalarWhereWithAggregatesInput!]
  active: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type InstrumentSong {
  createdAt: DateTime!
  file: String
  id: Int!
  instrumentId: Int
  mimeType: String
  notes: String
  songId: Int
  updatedAt: DateTime!
  words: String
}

input InstrumentSongCreateManyInstrumentsInput {
  createdAt: DateTime
  file: String
  id: Int
  mimeType: String
  notes: String
  songId: Int
  updatedAt: DateTime
  words: String
}

input InstrumentSongCreateManyInstrumentsInputEnvelope {
  data: [InstrumentSongCreateManyInstrumentsInput!]!
  skipDuplicates: Boolean
}

input InstrumentSongCreateManySongsInput {
  createdAt: DateTime
  file: String
  id: Int
  instrumentId: Int
  mimeType: String
  notes: String
  updatedAt: DateTime
  words: String
}

input InstrumentSongCreateManySongsInputEnvelope {
  data: [InstrumentSongCreateManySongsInput!]!
  skipDuplicates: Boolean
}

input InstrumentSongCreateNestedManyWithoutInstrumentsInput {
  connect: [InstrumentSongWhereUniqueInput!]
  connectOrCreate: [InstrumentSongCreateOrConnectWithoutInstrumentsInput!]
  create: [InstrumentSongCreateWithoutInstrumentsInput!]
  createMany: InstrumentSongCreateManyInstrumentsInputEnvelope
}

input InstrumentSongCreateNestedManyWithoutSongsInput {
  connect: [InstrumentSongWhereUniqueInput!]
  connectOrCreate: [InstrumentSongCreateOrConnectWithoutSongsInput!]
  create: [InstrumentSongCreateWithoutSongsInput!]
  createMany: InstrumentSongCreateManySongsInputEnvelope
}

input InstrumentSongCreateOrConnectWithoutInstrumentsInput {
  create: InstrumentSongCreateWithoutInstrumentsInput!
  where: InstrumentSongWhereUniqueInput!
}

input InstrumentSongCreateOrConnectWithoutSongsInput {
  create: InstrumentSongCreateWithoutSongsInput!
  where: InstrumentSongWhereUniqueInput!
}

input InstrumentSongCreateWithoutInstrumentsInput {
  createdAt: DateTime
  file: String
  mimeType: String
  notes: String
  songs: SongCreateNestedOneWithoutInstrumentsInput
  updatedAt: DateTime
  words: String
}

input InstrumentSongCreateWithoutSongsInput {
  createdAt: DateTime
  file: String
  instruments: InstrumentCreateNestedOneWithoutSongsInput
  mimeType: String
  notes: String
  updatedAt: DateTime
  words: String
}

input InstrumentSongListRelationFilter {
  every: InstrumentSongWhereInput
  none: InstrumentSongWhereInput
  some: InstrumentSongWhereInput
}

input InstrumentSongOrderByRelationAggregateInput {
  _count: SortOrder
}

input InstrumentSongOrderByWithRelationInput {
  createdAt: SortOrder
  file: SortOrder
  id: SortOrder
  instrumentId: SortOrder
  instruments: InstrumentOrderByWithRelationInput
  mimeType: SortOrder
  notes: SortOrder
  songId: SortOrder
  songs: SongOrderByWithRelationInput
  updatedAt: SortOrder
  words: SortOrder
}

enum InstrumentSongScalarFieldEnum {
  createdAt
  file
  id
  instrumentId
  mimeType
  notes
  songId
  updatedAt
  words
}

input InstrumentSongScalarWhereInput {
  AND: [InstrumentSongScalarWhereInput!]
  NOT: [InstrumentSongScalarWhereInput!]
  OR: [InstrumentSongScalarWhereInput!]
  createdAt: DateTimeFilter
  file: StringNullableFilter
  id: IntFilter
  instrumentId: IntNullableFilter
  mimeType: StringNullableFilter
  notes: StringNullableFilter
  songId: IntNullableFilter
  updatedAt: DateTimeFilter
  words: StringNullableFilter
}

input InstrumentSongUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  file: NullableStringFieldUpdateOperationsInput
  mimeType: NullableStringFieldUpdateOperationsInput
  notes: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  words: NullableStringFieldUpdateOperationsInput
}

input InstrumentSongUpdateManyWithWhereWithoutInstrumentsInput {
  data: InstrumentSongUpdateManyMutationInput!
  where: InstrumentSongScalarWhereInput!
}

input InstrumentSongUpdateManyWithWhereWithoutSongsInput {
  data: InstrumentSongUpdateManyMutationInput!
  where: InstrumentSongScalarWhereInput!
}

input InstrumentSongUpdateManyWithoutInstrumentsNestedInput {
  connect: [InstrumentSongWhereUniqueInput!]
  connectOrCreate: [InstrumentSongCreateOrConnectWithoutInstrumentsInput!]
  create: [InstrumentSongCreateWithoutInstrumentsInput!]
  createMany: InstrumentSongCreateManyInstrumentsInputEnvelope
  delete: [InstrumentSongWhereUniqueInput!]
  deleteMany: [InstrumentSongScalarWhereInput!]
  disconnect: [InstrumentSongWhereUniqueInput!]
  set: [InstrumentSongWhereUniqueInput!]
  update: [InstrumentSongUpdateWithWhereUniqueWithoutInstrumentsInput!]
  updateMany: [InstrumentSongUpdateManyWithWhereWithoutInstrumentsInput!]
  upsert: [InstrumentSongUpsertWithWhereUniqueWithoutInstrumentsInput!]
}

input InstrumentSongUpdateManyWithoutSongsNestedInput {
  connect: [InstrumentSongWhereUniqueInput!]
  connectOrCreate: [InstrumentSongCreateOrConnectWithoutSongsInput!]
  create: [InstrumentSongCreateWithoutSongsInput!]
  createMany: InstrumentSongCreateManySongsInputEnvelope
  delete: [InstrumentSongWhereUniqueInput!]
  deleteMany: [InstrumentSongScalarWhereInput!]
  disconnect: [InstrumentSongWhereUniqueInput!]
  set: [InstrumentSongWhereUniqueInput!]
  update: [InstrumentSongUpdateWithWhereUniqueWithoutSongsInput!]
  updateMany: [InstrumentSongUpdateManyWithWhereWithoutSongsInput!]
  upsert: [InstrumentSongUpsertWithWhereUniqueWithoutSongsInput!]
}

input InstrumentSongUpdateWithWhereUniqueWithoutInstrumentsInput {
  data: InstrumentSongUpdateWithoutInstrumentsInput!
  where: InstrumentSongWhereUniqueInput!
}

input InstrumentSongUpdateWithWhereUniqueWithoutSongsInput {
  data: InstrumentSongUpdateWithoutSongsInput!
  where: InstrumentSongWhereUniqueInput!
}

input InstrumentSongUpdateWithoutInstrumentsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  file: NullableStringFieldUpdateOperationsInput
  mimeType: NullableStringFieldUpdateOperationsInput
  notes: NullableStringFieldUpdateOperationsInput
  songs: SongUpdateOneWithoutInstrumentsNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  words: NullableStringFieldUpdateOperationsInput
}

input InstrumentSongUpdateWithoutSongsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  file: NullableStringFieldUpdateOperationsInput
  instruments: InstrumentUpdateOneWithoutSongsNestedInput
  mimeType: NullableStringFieldUpdateOperationsInput
  notes: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  words: NullableStringFieldUpdateOperationsInput
}

input InstrumentSongUpsertWithWhereUniqueWithoutInstrumentsInput {
  create: InstrumentSongCreateWithoutInstrumentsInput!
  update: InstrumentSongUpdateWithoutInstrumentsInput!
  where: InstrumentSongWhereUniqueInput!
}

input InstrumentSongUpsertWithWhereUniqueWithoutSongsInput {
  create: InstrumentSongCreateWithoutSongsInput!
  update: InstrumentSongUpdateWithoutSongsInput!
  where: InstrumentSongWhereUniqueInput!
}

input InstrumentSongWhereInput {
  AND: [InstrumentSongWhereInput!]
  NOT: [InstrumentSongWhereInput!]
  OR: [InstrumentSongWhereInput!]
  createdAt: DateTimeFilter
  file: StringNullableFilter
  id: IntFilter
  instrumentId: IntNullableFilter
  instruments: InstrumentRelationFilter
  mimeType: StringNullableFilter
  notes: StringNullableFilter
  songId: IntNullableFilter
  songs: SongRelationFilter
  updatedAt: DateTimeFilter
  words: StringNullableFilter
}

input InstrumentSongWhereUniqueInput {
  id: Int
}

type InstrumentSumAggregate {
  active: Int
  id: Int
}

input InstrumentSumOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
}

input InstrumentUpdateInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  songs: InstrumentSongUpdateManyWithoutInstrumentsNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input InstrumentUpdateManyMutationInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input InstrumentUpdateOneWithoutSongsNestedInput {
  connect: InstrumentWhereUniqueInput
  connectOrCreate: InstrumentCreateOrConnectWithoutSongsInput
  create: InstrumentCreateWithoutSongsInput
  delete: Boolean
  disconnect: Boolean
  update: InstrumentUpdateWithoutSongsInput
  upsert: InstrumentUpsertWithoutSongsInput
}

input InstrumentUpdateWithoutSongsInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input InstrumentUpsertWithoutSongsInput {
  create: InstrumentCreateWithoutSongsInput!
  update: InstrumentUpdateWithoutSongsInput!
}

input InstrumentWhereInput {
  AND: [InstrumentWhereInput!]
  NOT: [InstrumentWhereInput!]
  OR: [InstrumentWhereInput!]
  active: IntFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
  songs: InstrumentSongListRelationFilter
  updatedAt: DateTimeFilter
}

input InstrumentWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyEvent(data: [EventCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyInstrument(data: [InstrumentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySession(data: [SessionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySong(data: [SongCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneEvent(data: EventCreateInput!): Event!
  createOneInstrument(data: InstrumentCreateInput!): Instrument!
  createOneSession(data: SessionCreateInput!): Session!
  createOneSong(data: SongCreateInput!): Song!
  createOneUser(data: UserCreateInput!): User!
  deleteManyEvent(where: EventWhereInput): AffectedRowsOutput!
  deleteManyInstrument(where: InstrumentWhereInput): AffectedRowsOutput!
  deleteManySession(where: SessionWhereInput): AffectedRowsOutput!
  deleteManySong(where: SongWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneEvent(where: EventWhereUniqueInput!): Event
  deleteOneInstrument(where: InstrumentWhereUniqueInput!): Instrument
  deleteOneSession(where: SessionWhereUniqueInput!): Session
  deleteOneSong(where: SongWhereUniqueInput!): Song
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyEvent(data: EventUpdateManyMutationInput!, where: EventWhereInput): AffectedRowsOutput!
  updateManyInstrument(data: InstrumentUpdateManyMutationInput!, where: InstrumentWhereInput): AffectedRowsOutput!
  updateManySession(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): AffectedRowsOutput!
  updateManySong(data: SongUpdateManyMutationInput!, where: SongWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateOneInstrument(data: InstrumentUpdateInput!, where: InstrumentWhereUniqueInput!): Instrument
  updateOneSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateOneSong(data: SongUpdateInput!, where: SongWhereUniqueInput!): Song
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneEvent(create: EventCreateInput!, update: EventUpdateInput!, where: EventWhereUniqueInput!): Event!
  upsertOneInstrument(create: InstrumentCreateInput!, update: InstrumentUpdateInput!, where: InstrumentWhereUniqueInput!): Instrument!
  upsertOneSession(create: SessionCreateInput!, update: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session!
  upsertOneSong(create: SongCreateInput!, update: SongUpdateInput!, where: SongWhereUniqueInput!): Song!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumToken_typeFilter {
  equals: Token_type
  in: [Token_type!]
  not: NestedEnumToken_typeFilter
  notIn: [Token_type!]
}

input NestedEnumUser_roleFilter {
  equals: User_role
  in: [User_role!]
  not: NestedEnumUser_roleFilter
  notIn: [User_role!]
}

input NestedEnumUser_roleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumUser_roleFilter
  _min: NestedEnumUser_roleFilter
  equals: User_role
  in: [User_role!]
  not: NestedEnumUser_roleWithAggregatesFilter
  notIn: [User_role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Profile {
  bio: String!
  createdAt: DateTime!
  id: Int!
  updatedAt: DateTime!
  userId: Int
}

input ProfileCreateNestedOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  connectOrCreate: ProfileCreateOrConnectWithoutUserInput
  create: ProfileCreateWithoutUserInput
}

input ProfileCreateOrConnectWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  where: ProfileWhereUniqueInput!
}

input ProfileCreateWithoutUserInput {
  bio: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input ProfileOrderByWithRelationInput {
  bio: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input ProfileRelationFilter {
  is: ProfileWhereInput
  isNot: ProfileWhereInput
}

input ProfileUpdateOneWithoutUserNestedInput {
  connect: ProfileWhereUniqueInput
  connectOrCreate: ProfileCreateOrConnectWithoutUserInput
  create: ProfileCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateWithoutUserInput
  upsert: ProfileUpsertWithoutUserInput
}

input ProfileUpdateWithoutUserInput {
  bio: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProfileUpsertWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  update: ProfileUpdateWithoutUserInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  bio: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntNullableFilter
}

input ProfileWhereUniqueInput {
  id: Int
  userId: Int
}

type Query {
  aggregateEvent(cursor: EventWhereUniqueInput, orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): AggregateEvent!
  aggregateInstrument(cursor: InstrumentWhereUniqueInput, orderBy: [InstrumentOrderByWithRelationInput!], skip: Int, take: Int, where: InstrumentWhereInput): AggregateInstrument!
  aggregateSession(cursor: SessionWhereUniqueInput, orderBy: [SessionOrderByWithRelationInput!], skip: Int, take: Int, where: SessionWhereInput): AggregateSession!
  aggregateSong(cursor: SongWhereUniqueInput, orderBy: [SongOrderByWithRelationInput!], skip: Int, take: Int, where: SongWhereInput): AggregateSong!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  event(where: EventWhereUniqueInput!): Event
  events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
  findFirstEvent(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): Event
  findFirstInstrument(cursor: InstrumentWhereUniqueInput, distinct: [InstrumentScalarFieldEnum!], orderBy: [InstrumentOrderByWithRelationInput!], skip: Int, take: Int, where: InstrumentWhereInput): Instrument
  findFirstSession(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationInput!], skip: Int, take: Int, where: SessionWhereInput): Session
  findFirstSong(cursor: SongWhereUniqueInput, distinct: [SongScalarFieldEnum!], orderBy: [SongOrderByWithRelationInput!], skip: Int, take: Int, where: SongWhereInput): Song
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByEvent(by: [EventScalarFieldEnum!]!, having: EventScalarWhereWithAggregatesInput, orderBy: [EventOrderByWithAggregationInput!], skip: Int, take: Int, where: EventWhereInput): [EventGroupBy!]!
  groupByInstrument(by: [InstrumentScalarFieldEnum!]!, having: InstrumentScalarWhereWithAggregatesInput, orderBy: [InstrumentOrderByWithAggregationInput!], skip: Int, take: Int, where: InstrumentWhereInput): [InstrumentGroupBy!]!
  groupBySession(by: [SessionScalarFieldEnum!]!, having: SessionScalarWhereWithAggregatesInput, orderBy: [SessionOrderByWithAggregationInput!], skip: Int, take: Int, where: SessionWhereInput): [SessionGroupBy!]!
  groupBySong(by: [SongScalarFieldEnum!]!, having: SongScalarWhereWithAggregatesInput, orderBy: [SongOrderByWithAggregationInput!], skip: Int, take: Int, where: SongWhereInput): [SongGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  instrument(where: InstrumentWhereUniqueInput!): Instrument
  instruments(cursor: InstrumentWhereUniqueInput, distinct: [InstrumentScalarFieldEnum!], orderBy: [InstrumentOrderByWithRelationInput!], skip: Int, take: Int, where: InstrumentWhereInput): [Instrument!]!
  session(where: SessionWhereUniqueInput!): Session
  sessions(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationInput!], skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  song(where: SongWhereUniqueInput!): Song
  songs(cursor: SongWhereUniqueInput, distinct: [SongScalarFieldEnum!], orderBy: [SongOrderByWithRelationInput!], skip: Int, take: Int, where: SongWhereInput): [Song!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type Session {
  antiCSRFToken: String
  createdAt: DateTime!
  expiresAt: DateTime
  handle: String!
  hashedSessionToken: String
  id: Int!
  privateData: String
  publicData: String
  updatedAt: DateTime!
  user: User
  userId: Int
}

type SessionAvgAggregate {
  id: Float
  userId: Float
}

input SessionAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type SessionCountAggregate {
  _all: Int!
  antiCSRFToken: Int!
  createdAt: Int!
  expiresAt: Int!
  handle: Int!
  hashedSessionToken: Int!
  id: Int!
  privateData: Int!
  publicData: Int!
  updatedAt: Int!
  userId: Int!
}

input SessionCountOrderByAggregateInput {
  antiCSRFToken: SortOrder
  createdAt: SortOrder
  expiresAt: SortOrder
  handle: SortOrder
  hashedSessionToken: SortOrder
  id: SortOrder
  privateData: SortOrder
  publicData: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionCreateInput {
  antiCSRFToken: String
  createdAt: DateTime
  expiresAt: DateTime
  handle: String!
  hashedSessionToken: String
  privateData: String
  publicData: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutSessionsInput
}

input SessionCreateManyInput {
  antiCSRFToken: String
  createdAt: DateTime
  expiresAt: DateTime
  handle: String!
  hashedSessionToken: String
  id: Int
  privateData: String
  publicData: String
  updatedAt: DateTime
  userId: Int
}

input SessionCreateManyUserInput {
  antiCSRFToken: String
  createdAt: DateTime
  expiresAt: DateTime
  handle: String!
  hashedSessionToken: String
  id: Int
  privateData: String
  publicData: String
  updatedAt: DateTime
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateNestedManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
}

input SessionCreateOrConnectWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionCreateWithoutUserInput {
  antiCSRFToken: String
  createdAt: DateTime
  expiresAt: DateTime
  handle: String!
  hashedSessionToken: String
  privateData: String
  publicData: String
  updatedAt: DateTime
}

type SessionGroupBy {
  _avg: SessionAvgAggregate
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
  _sum: SessionSumAggregate
  antiCSRFToken: String
  createdAt: DateTime!
  expiresAt: DateTime
  handle: String!
  hashedSessionToken: String
  id: Int!
  privateData: String
  publicData: String
  updatedAt: DateTime!
  userId: Int
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

type SessionMaxAggregate {
  antiCSRFToken: String
  createdAt: DateTime
  expiresAt: DateTime
  handle: String
  hashedSessionToken: String
  id: Int
  privateData: String
  publicData: String
  updatedAt: DateTime
  userId: Int
}

input SessionMaxOrderByAggregateInput {
  antiCSRFToken: SortOrder
  createdAt: SortOrder
  expiresAt: SortOrder
  handle: SortOrder
  hashedSessionToken: SortOrder
  id: SortOrder
  privateData: SortOrder
  publicData: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type SessionMinAggregate {
  antiCSRFToken: String
  createdAt: DateTime
  expiresAt: DateTime
  handle: String
  hashedSessionToken: String
  id: Int
  privateData: String
  publicData: String
  updatedAt: DateTime
  userId: Int
}

input SessionMinOrderByAggregateInput {
  antiCSRFToken: SortOrder
  createdAt: SortOrder
  expiresAt: SortOrder
  handle: SortOrder
  hashedSessionToken: SortOrder
  id: SortOrder
  privateData: SortOrder
  publicData: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SessionOrderByWithAggregationInput {
  _avg: SessionAvgOrderByAggregateInput
  _count: SessionCountOrderByAggregateInput
  _max: SessionMaxOrderByAggregateInput
  _min: SessionMinOrderByAggregateInput
  _sum: SessionSumOrderByAggregateInput
  antiCSRFToken: SortOrder
  createdAt: SortOrder
  expiresAt: SortOrder
  handle: SortOrder
  hashedSessionToken: SortOrder
  id: SortOrder
  privateData: SortOrder
  publicData: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionOrderByWithRelationInput {
  antiCSRFToken: SortOrder
  createdAt: SortOrder
  expiresAt: SortOrder
  handle: SortOrder
  hashedSessionToken: SortOrder
  id: SortOrder
  privateData: SortOrder
  publicData: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum SessionScalarFieldEnum {
  antiCSRFToken
  createdAt
  expiresAt
  handle
  hashedSessionToken
  id
  privateData
  publicData
  updatedAt
  userId
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  antiCSRFToken: StringNullableFilter
  createdAt: DateTimeFilter
  expiresAt: DateTimeNullableFilter
  handle: StringFilter
  hashedSessionToken: StringNullableFilter
  id: IntFilter
  privateData: StringNullableFilter
  publicData: StringNullableFilter
  updatedAt: DateTimeFilter
  userId: IntNullableFilter
}

input SessionScalarWhereWithAggregatesInput {
  AND: [SessionScalarWhereWithAggregatesInput!]
  NOT: [SessionScalarWhereWithAggregatesInput!]
  OR: [SessionScalarWhereWithAggregatesInput!]
  antiCSRFToken: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  expiresAt: DateTimeNullableWithAggregatesFilter
  handle: StringWithAggregatesFilter
  hashedSessionToken: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  privateData: StringNullableWithAggregatesFilter
  publicData: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntNullableWithAggregatesFilter
}

type SessionSumAggregate {
  id: Int
  userId: Int
}

input SessionSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input SessionUpdateInput {
  antiCSRFToken: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expiresAt: NullableDateTimeFieldUpdateOperationsInput
  handle: StringFieldUpdateOperationsInput
  hashedSessionToken: NullableStringFieldUpdateOperationsInput
  privateData: NullableStringFieldUpdateOperationsInput
  publicData: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutSessionsNestedInput
}

input SessionUpdateManyMutationInput {
  antiCSRFToken: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expiresAt: NullableDateTimeFieldUpdateOperationsInput
  handle: StringFieldUpdateOperationsInput
  hashedSessionToken: NullableStringFieldUpdateOperationsInput
  privateData: NullableStringFieldUpdateOperationsInput
  publicData: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SessionUpdateManyWithWhereWithoutUserInput {
  data: SessionUpdateManyMutationInput!
  where: SessionScalarWhereInput!
}

input SessionUpdateManyWithoutUserNestedInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  delete: [SessionWhereUniqueInput!]
  deleteMany: [SessionScalarWhereInput!]
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  data: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionUpdateWithoutUserInput {
  antiCSRFToken: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expiresAt: NullableDateTimeFieldUpdateOperationsInput
  handle: StringFieldUpdateOperationsInput
  hashedSessionToken: NullableStringFieldUpdateOperationsInput
  privateData: NullableStringFieldUpdateOperationsInput
  publicData: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  update: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  antiCSRFToken: StringNullableFilter
  createdAt: DateTimeFilter
  expiresAt: DateTimeNullableFilter
  handle: StringFilter
  hashedSessionToken: StringNullableFilter
  id: IntFilter
  privateData: StringNullableFilter
  publicData: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntNullableFilter
}

input SessionWhereUniqueInput {
  handle: String
  id: Int
}

type Song {
  _count: SongCount
  active: Int!
  alias: String
  arrangement: String
  createdAt: DateTime!
  events(cursor: EventSongWhereUniqueInput, distinct: [EventSongScalarFieldEnum!], orderBy: [EventSongOrderByWithRelationInput!], skip: Int, take: Int, where: EventSongWhereInput): [EventSong!]!
  id: Int!
  instruments(cursor: InstrumentSongWhereUniqueInput, distinct: [InstrumentSongScalarFieldEnum!], orderBy: [InstrumentSongOrderByWithRelationInput!], skip: Int, take: Int, where: InstrumentSongWhereInput): [InstrumentSong!]!
  startKey: String
  startWords: String
  tags(cursor: SongTagsWhereUniqueInput, distinct: [SongTagsScalarFieldEnum!], orderBy: [SongTagsOrderByWithRelationInput!], skip: Int, take: Int, where: SongTagsWhereInput): [SongTags!]!
  tempoCd: Int!
  title: String!
  updatedAt: DateTime!
}

type SongAvgAggregate {
  active: Float
  id: Float
  tempoCd: Float
}

input SongAvgOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
  tempoCd: SortOrder
}

type SongCount {
  events: Int!
  instruments: Int!
  tags: Int!
}

type SongCountAggregate {
  _all: Int!
  active: Int!
  alias: Int!
  arrangement: Int!
  createdAt: Int!
  id: Int!
  startKey: Int!
  startWords: Int!
  tempoCd: Int!
  title: Int!
  updatedAt: Int!
}

input SongCountOrderByAggregateInput {
  active: SortOrder
  alias: SortOrder
  arrangement: SortOrder
  createdAt: SortOrder
  id: SortOrder
  startKey: SortOrder
  startWords: SortOrder
  tempoCd: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SongCreateInput {
  active: Int!
  alias: String
  arrangement: String
  createdAt: DateTime
  events: EventSongCreateNestedManyWithoutSongInput
  instruments: InstrumentSongCreateNestedManyWithoutSongsInput
  startKey: String
  startWords: String
  tags: SongTagsCreateNestedManyWithoutSongInput
  tempoCd: Int!
  title: String!
  updatedAt: DateTime
}

input SongCreateManyInput {
  active: Int!
  alias: String
  arrangement: String
  createdAt: DateTime
  id: Int
  startKey: String
  startWords: String
  tempoCd: Int!
  title: String!
  updatedAt: DateTime
}

input SongCreateNestedOneWithoutEventsInput {
  connect: SongWhereUniqueInput
  connectOrCreate: SongCreateOrConnectWithoutEventsInput
  create: SongCreateWithoutEventsInput
}

input SongCreateNestedOneWithoutInstrumentsInput {
  connect: SongWhereUniqueInput
  connectOrCreate: SongCreateOrConnectWithoutInstrumentsInput
  create: SongCreateWithoutInstrumentsInput
}

input SongCreateOrConnectWithoutEventsInput {
  create: SongCreateWithoutEventsInput!
  where: SongWhereUniqueInput!
}

input SongCreateOrConnectWithoutInstrumentsInput {
  create: SongCreateWithoutInstrumentsInput!
  where: SongWhereUniqueInput!
}

input SongCreateWithoutEventsInput {
  active: Int!
  alias: String
  arrangement: String
  createdAt: DateTime
  instruments: InstrumentSongCreateNestedManyWithoutSongsInput
  startKey: String
  startWords: String
  tags: SongTagsCreateNestedManyWithoutSongInput
  tempoCd: Int!
  title: String!
  updatedAt: DateTime
}

input SongCreateWithoutInstrumentsInput {
  active: Int!
  alias: String
  arrangement: String
  createdAt: DateTime
  events: EventSongCreateNestedManyWithoutSongInput
  startKey: String
  startWords: String
  tags: SongTagsCreateNestedManyWithoutSongInput
  tempoCd: Int!
  title: String!
  updatedAt: DateTime
}

type SongGroupBy {
  _avg: SongAvgAggregate
  _count: SongCountAggregate
  _max: SongMaxAggregate
  _min: SongMinAggregate
  _sum: SongSumAggregate
  active: Int!
  alias: String
  arrangement: String
  createdAt: DateTime!
  id: Int!
  startKey: String
  startWords: String
  tempoCd: Int!
  title: String!
  updatedAt: DateTime!
}

type SongMaxAggregate {
  active: Int
  alias: String
  arrangement: String
  createdAt: DateTime
  id: Int
  startKey: String
  startWords: String
  tempoCd: Int
  title: String
  updatedAt: DateTime
}

input SongMaxOrderByAggregateInput {
  active: SortOrder
  alias: SortOrder
  arrangement: SortOrder
  createdAt: SortOrder
  id: SortOrder
  startKey: SortOrder
  startWords: SortOrder
  tempoCd: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type SongMinAggregate {
  active: Int
  alias: String
  arrangement: String
  createdAt: DateTime
  id: Int
  startKey: String
  startWords: String
  tempoCd: Int
  title: String
  updatedAt: DateTime
}

input SongMinOrderByAggregateInput {
  active: SortOrder
  alias: SortOrder
  arrangement: SortOrder
  createdAt: SortOrder
  id: SortOrder
  startKey: SortOrder
  startWords: SortOrder
  tempoCd: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SongOrderByWithAggregationInput {
  _avg: SongAvgOrderByAggregateInput
  _count: SongCountOrderByAggregateInput
  _max: SongMaxOrderByAggregateInput
  _min: SongMinOrderByAggregateInput
  _sum: SongSumOrderByAggregateInput
  active: SortOrder
  alias: SortOrder
  arrangement: SortOrder
  createdAt: SortOrder
  id: SortOrder
  startKey: SortOrder
  startWords: SortOrder
  tempoCd: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SongOrderByWithRelationInput {
  active: SortOrder
  alias: SortOrder
  arrangement: SortOrder
  createdAt: SortOrder
  events: EventSongOrderByRelationAggregateInput
  id: SortOrder
  instruments: InstrumentSongOrderByRelationAggregateInput
  startKey: SortOrder
  startWords: SortOrder
  tags: SongTagsOrderByRelationAggregateInput
  tempoCd: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input SongRelationFilter {
  is: SongWhereInput
  isNot: SongWhereInput
}

enum SongScalarFieldEnum {
  active
  alias
  arrangement
  createdAt
  id
  startKey
  startWords
  tempoCd
  title
  updatedAt
}

input SongScalarWhereWithAggregatesInput {
  AND: [SongScalarWhereWithAggregatesInput!]
  NOT: [SongScalarWhereWithAggregatesInput!]
  OR: [SongScalarWhereWithAggregatesInput!]
  active: IntWithAggregatesFilter
  alias: StringNullableWithAggregatesFilter
  arrangement: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  startKey: StringNullableWithAggregatesFilter
  startWords: StringNullableWithAggregatesFilter
  tempoCd: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SongSumAggregate {
  active: Int
  id: Int
  tempoCd: Int
}

input SongSumOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
  tempoCd: SortOrder
}

type SongTags {
  createdAt: DateTime!
  id: Int!
  songId: Int
  tagId: Int
}

input SongTagsCreateManySongInput {
  createdAt: DateTime
  id: Int
  tagId: Int
}

input SongTagsCreateManySongInputEnvelope {
  data: [SongTagsCreateManySongInput!]!
  skipDuplicates: Boolean
}

input SongTagsCreateNestedManyWithoutSongInput {
  connect: [SongTagsWhereUniqueInput!]
  connectOrCreate: [SongTagsCreateOrConnectWithoutSongInput!]
  create: [SongTagsCreateWithoutSongInput!]
  createMany: SongTagsCreateManySongInputEnvelope
}

input SongTagsCreateOrConnectWithoutSongInput {
  create: SongTagsCreateWithoutSongInput!
  where: SongTagsWhereUniqueInput!
}

input SongTagsCreateWithoutSongInput {
  createdAt: DateTime
  tag: TagCreateNestedOneWithoutSongsInput
}

input SongTagsListRelationFilter {
  every: SongTagsWhereInput
  none: SongTagsWhereInput
  some: SongTagsWhereInput
}

input SongTagsOrderByRelationAggregateInput {
  _count: SortOrder
}

input SongTagsOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  song: SongOrderByWithRelationInput
  songId: SortOrder
  tag: TagOrderByWithRelationInput
  tagId: SortOrder
}

enum SongTagsScalarFieldEnum {
  createdAt
  id
  songId
  tagId
}

input SongTagsScalarWhereInput {
  AND: [SongTagsScalarWhereInput!]
  NOT: [SongTagsScalarWhereInput!]
  OR: [SongTagsScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  songId: IntNullableFilter
  tagId: IntNullableFilter
}

input SongTagsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
}

input SongTagsUpdateManyWithWhereWithoutSongInput {
  data: SongTagsUpdateManyMutationInput!
  where: SongTagsScalarWhereInput!
}

input SongTagsUpdateManyWithoutSongNestedInput {
  connect: [SongTagsWhereUniqueInput!]
  connectOrCreate: [SongTagsCreateOrConnectWithoutSongInput!]
  create: [SongTagsCreateWithoutSongInput!]
  createMany: SongTagsCreateManySongInputEnvelope
  delete: [SongTagsWhereUniqueInput!]
  deleteMany: [SongTagsScalarWhereInput!]
  disconnect: [SongTagsWhereUniqueInput!]
  set: [SongTagsWhereUniqueInput!]
  update: [SongTagsUpdateWithWhereUniqueWithoutSongInput!]
  updateMany: [SongTagsUpdateManyWithWhereWithoutSongInput!]
  upsert: [SongTagsUpsertWithWhereUniqueWithoutSongInput!]
}

input SongTagsUpdateWithWhereUniqueWithoutSongInput {
  data: SongTagsUpdateWithoutSongInput!
  where: SongTagsWhereUniqueInput!
}

input SongTagsUpdateWithoutSongInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  tag: TagUpdateOneWithoutSongsNestedInput
}

input SongTagsUpsertWithWhereUniqueWithoutSongInput {
  create: SongTagsCreateWithoutSongInput!
  update: SongTagsUpdateWithoutSongInput!
  where: SongTagsWhereUniqueInput!
}

input SongTagsWhereInput {
  AND: [SongTagsWhereInput!]
  NOT: [SongTagsWhereInput!]
  OR: [SongTagsWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  song: SongRelationFilter
  songId: IntNullableFilter
  tag: TagRelationFilter
  tagId: IntNullableFilter
}

input SongTagsWhereUniqueInput {
  id: Int
}

input SongUpdateInput {
  active: IntFieldUpdateOperationsInput
  alias: NullableStringFieldUpdateOperationsInput
  arrangement: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  events: EventSongUpdateManyWithoutSongNestedInput
  instruments: InstrumentSongUpdateManyWithoutSongsNestedInput
  startKey: NullableStringFieldUpdateOperationsInput
  startWords: NullableStringFieldUpdateOperationsInput
  tags: SongTagsUpdateManyWithoutSongNestedInput
  tempoCd: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SongUpdateManyMutationInput {
  active: IntFieldUpdateOperationsInput
  alias: NullableStringFieldUpdateOperationsInput
  arrangement: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  startKey: NullableStringFieldUpdateOperationsInput
  startWords: NullableStringFieldUpdateOperationsInput
  tempoCd: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SongUpdateOneWithoutEventsNestedInput {
  connect: SongWhereUniqueInput
  connectOrCreate: SongCreateOrConnectWithoutEventsInput
  create: SongCreateWithoutEventsInput
  delete: Boolean
  disconnect: Boolean
  update: SongUpdateWithoutEventsInput
  upsert: SongUpsertWithoutEventsInput
}

input SongUpdateOneWithoutInstrumentsNestedInput {
  connect: SongWhereUniqueInput
  connectOrCreate: SongCreateOrConnectWithoutInstrumentsInput
  create: SongCreateWithoutInstrumentsInput
  delete: Boolean
  disconnect: Boolean
  update: SongUpdateWithoutInstrumentsInput
  upsert: SongUpsertWithoutInstrumentsInput
}

input SongUpdateWithoutEventsInput {
  active: IntFieldUpdateOperationsInput
  alias: NullableStringFieldUpdateOperationsInput
  arrangement: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  instruments: InstrumentSongUpdateManyWithoutSongsNestedInput
  startKey: NullableStringFieldUpdateOperationsInput
  startWords: NullableStringFieldUpdateOperationsInput
  tags: SongTagsUpdateManyWithoutSongNestedInput
  tempoCd: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SongUpdateWithoutInstrumentsInput {
  active: IntFieldUpdateOperationsInput
  alias: NullableStringFieldUpdateOperationsInput
  arrangement: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  events: EventSongUpdateManyWithoutSongNestedInput
  startKey: NullableStringFieldUpdateOperationsInput
  startWords: NullableStringFieldUpdateOperationsInput
  tags: SongTagsUpdateManyWithoutSongNestedInput
  tempoCd: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SongUpsertWithoutEventsInput {
  create: SongCreateWithoutEventsInput!
  update: SongUpdateWithoutEventsInput!
}

input SongUpsertWithoutInstrumentsInput {
  create: SongCreateWithoutInstrumentsInput!
  update: SongUpdateWithoutInstrumentsInput!
}

input SongWhereInput {
  AND: [SongWhereInput!]
  NOT: [SongWhereInput!]
  OR: [SongWhereInput!]
  active: IntFilter
  alias: StringNullableFilter
  arrangement: StringNullableFilter
  createdAt: DateTimeFilter
  events: EventSongListRelationFilter
  id: IntFilter
  instruments: InstrumentSongListRelationFilter
  startKey: StringNullableFilter
  startWords: StringNullableFilter
  tags: SongTagsListRelationFilter
  tempoCd: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input SongWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input TagCreateNestedOneWithoutSongsInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutSongsInput
  create: TagCreateWithoutSongsInput
}

input TagCreateOrConnectWithoutSongsInput {
  create: TagCreateWithoutSongsInput!
  where: TagWhereUniqueInput!
}

input TagCreateWithoutSongsInput {
  name: String!
}

input TagOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  songs: SongTagsOrderByRelationAggregateInput
}

input TagRelationFilter {
  is: TagWhereInput
  isNot: TagWhereInput
}

input TagUpdateOneWithoutSongsNestedInput {
  connect: TagWhereUniqueInput
  connectOrCreate: TagCreateOrConnectWithoutSongsInput
  create: TagCreateWithoutSongsInput
  delete: Boolean
  disconnect: Boolean
  update: TagUpdateWithoutSongsInput
  upsert: TagUpsertWithoutSongsInput
}

input TagUpdateWithoutSongsInput {
  name: StringFieldUpdateOperationsInput
}

input TagUpsertWithoutSongsInput {
  create: TagCreateWithoutSongsInput!
  update: TagUpdateWithoutSongsInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  id: IntFilter
  name: StringFilter
  songs: SongTagsListRelationFilter
}

input TagWhereUniqueInput {
  id: Int
  name: String
}

type Token {
  createdAt: DateTime!
  expiresAt: DateTime!
  hashedToken: String!
  id: Int!
  sentTo: String!
  type: Token_type!
  updatedAt: DateTime!
  userId: Int
}

input TokenCreateManyUserInput {
  createdAt: DateTime
  expiresAt: DateTime!
  hashedToken: String!
  id: Int
  sentTo: String!
  type: Token_type!
  updatedAt: DateTime
}

input TokenCreateManyUserInputEnvelope {
  data: [TokenCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input TokenCreateNestedManyWithoutUserInput {
  connect: [TokenWhereUniqueInput!]
  connectOrCreate: [TokenCreateOrConnectWithoutUserInput!]
  create: [TokenCreateWithoutUserInput!]
  createMany: TokenCreateManyUserInputEnvelope
}

input TokenCreateOrConnectWithoutUserInput {
  create: TokenCreateWithoutUserInput!
  where: TokenWhereUniqueInput!
}

input TokenCreateWithoutUserInput {
  createdAt: DateTime
  expiresAt: DateTime!
  hashedToken: String!
  sentTo: String!
  type: Token_type!
  updatedAt: DateTime
}

input TokenHashedTokenTypeCompoundUniqueInput {
  hashedToken: String!
  type: Token_type!
}

input TokenListRelationFilter {
  every: TokenWhereInput
  none: TokenWhereInput
  some: TokenWhereInput
}

input TokenOrderByRelationAggregateInput {
  _count: SortOrder
}

input TokenOrderByWithRelationInput {
  createdAt: SortOrder
  expiresAt: SortOrder
  hashedToken: SortOrder
  id: SortOrder
  sentTo: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum TokenScalarFieldEnum {
  createdAt
  expiresAt
  hashedToken
  id
  sentTo
  type
  updatedAt
  userId
}

input TokenScalarWhereInput {
  AND: [TokenScalarWhereInput!]
  NOT: [TokenScalarWhereInput!]
  OR: [TokenScalarWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  hashedToken: StringFilter
  id: IntFilter
  sentTo: StringFilter
  type: EnumToken_typeFilter
  updatedAt: DateTimeFilter
  userId: IntNullableFilter
}

input TokenUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expiresAt: DateTimeFieldUpdateOperationsInput
  hashedToken: StringFieldUpdateOperationsInput
  sentTo: StringFieldUpdateOperationsInput
  type: EnumToken_typeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TokenUpdateManyWithWhereWithoutUserInput {
  data: TokenUpdateManyMutationInput!
  where: TokenScalarWhereInput!
}

input TokenUpdateManyWithoutUserNestedInput {
  connect: [TokenWhereUniqueInput!]
  connectOrCreate: [TokenCreateOrConnectWithoutUserInput!]
  create: [TokenCreateWithoutUserInput!]
  createMany: TokenCreateManyUserInputEnvelope
  delete: [TokenWhereUniqueInput!]
  deleteMany: [TokenScalarWhereInput!]
  disconnect: [TokenWhereUniqueInput!]
  set: [TokenWhereUniqueInput!]
  update: [TokenUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TokenUpdateManyWithWhereWithoutUserInput!]
  upsert: [TokenUpsertWithWhereUniqueWithoutUserInput!]
}

input TokenUpdateWithWhereUniqueWithoutUserInput {
  data: TokenUpdateWithoutUserInput!
  where: TokenWhereUniqueInput!
}

input TokenUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expiresAt: DateTimeFieldUpdateOperationsInput
  hashedToken: StringFieldUpdateOperationsInput
  sentTo: StringFieldUpdateOperationsInput
  type: EnumToken_typeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TokenUpsertWithWhereUniqueWithoutUserInput {
  create: TokenCreateWithoutUserInput!
  update: TokenUpdateWithoutUserInput!
  where: TokenWhereUniqueInput!
}

input TokenWhereInput {
  AND: [TokenWhereInput!]
  NOT: [TokenWhereInput!]
  OR: [TokenWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  hashedToken: StringFilter
  id: IntFilter
  sentTo: StringFilter
  type: EnumToken_typeFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntNullableFilter
}

input TokenWhereUniqueInput {
  hashedToken_type: TokenHashedTokenTypeCompoundUniqueInput
  id: Int
}

enum Token_type {
  RESET_PASSWORD
}

type User {
  _count: UserCount
  active: Int!
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  password: String!
  profile: Profile
  role: User_role!
  sessions(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationInput!], skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  tokens(cursor: TokenWhereUniqueInput, distinct: [TokenScalarFieldEnum!], orderBy: [TokenOrderByWithRelationInput!], skip: Int, take: Int, where: TokenWhereInput): [Token!]!
  updatedAt: DateTime!
}

type UserAvgAggregate {
  active: Float
  id: Float
}

input UserAvgOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
}

type UserCount {
  sessions: Int!
  tokens: Int!
}

type UserCountAggregate {
  _all: Int!
  active: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  password: Int!
  role: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  active: Int!
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  profile: ProfileCreateNestedOneWithoutUserInput
  role: User_role
  sessions: SessionCreateNestedManyWithoutUserInput
  tokens: TokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  active: Int!
  createdAt: DateTime
  email: String!
  id: Int
  name: String!
  password: String!
  role: User_role
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutSessionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
}

input UserCreateOrConnectWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutSessionsInput {
  active: Int!
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  profile: ProfileCreateNestedOneWithoutUserInput
  role: User_role
  tokens: TokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserEmailActiveCompoundUniqueInput {
  active: Int!
  email: String!
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  active: Int!
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  password: String!
  role: User_role!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  active: Int
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  role: User_role
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  active: Int
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  role: User_role
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  active: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  profile: ProfileOrderByWithRelationInput
  role: SortOrder
  sessions: SessionOrderByRelationAggregateInput
  tokens: TokenOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  active
  createdAt
  email
  id
  name
  password
  role
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  active: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: EnumUser_roleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  active: Int
  id: Int
}

input UserSumOrderByAggregateInput {
  active: SortOrder
  id: SortOrder
}

input UserUpdateInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profile: ProfileUpdateOneWithoutUserNestedInput
  role: EnumUser_roleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  tokens: TokenUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumUser_roleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneWithoutSessionsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutSessionsInput
  upsert: UserUpsertWithoutSessionsInput
}

input UserUpdateWithoutSessionsInput {
  active: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profile: ProfileUpdateOneWithoutUserNestedInput
  role: EnumUser_roleFieldUpdateOperationsInput
  tokens: TokenUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  update: UserUpdateWithoutSessionsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  active: IntFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  password: StringFilter
  profile: ProfileRelationFilter
  role: EnumUser_roleFilter
  sessions: SessionListRelationFilter
  tokens: TokenListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  email_active: UserEmailActiveCompoundUniqueInput
  id: Int
}

enum User_role {
  ADMIN
  EDITOR
  LEADER
  USER
}
